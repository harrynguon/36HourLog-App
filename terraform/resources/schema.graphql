# Use subscriptions for large objects, small changes or extremely low latency apps

schema {
  query: Query,
  mutation: Mutation
}

type Item {
  DeviceID: String!
  ExpiryDate: String!,
  Description: String
}

type ItemConnection {
  items: [Item]
  nextToken: String
}

type Query {
  getItem(DeviceID: String!, ExpiryDate: String!): Item
  listItems(filter: TableItemFilterInput, limit: Int, nextToken: String): ItemConnection
}

type Mutation {
  createItem(DeviceID: String!, ExpiryDate: String!, Description: String!): Item
  updateItem(DeviceID: String!, Description: String!): Item
  deleteItem(DeviceID: String!, Description: String): Item
}

input TableItemFilterInput {
  DeviceID: TableStringFilterInput
}

input TableStringFilterInput {
  ne: String
  eq: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
}